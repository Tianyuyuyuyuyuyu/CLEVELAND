# 享元模式

# 引言

大家都知道单例模式，通过一个全局变量来避免重复创建对象而产生的消耗，若系统存在大量的相似对象时，又该如何处理？参照单例模式，可通过对象池缓存可共享的对象，避免创建多对象，尽可能减少内存的使用，提升性能，防止内存溢出。

在软件开发过程，如果我们**需要重复使用某个对象的时候，如果我们重复地使用new创建这个对象的话，这样我们在内存就需要多次地去申请内存空间了，这样可能会出现内存使用越来越多的情况**，这样的问题是非常严重，然而享元模式可以解决这个问题，下面具体看看享元模式是如何去解决这个问题的。

# 定义

共享元对象，运用共享技术有效地支持大量细粒度对象的复用。

如果在一个系统中存在多个相同的对象，那么只需要共享一份对象的拷贝，而不必为每一次使用创建新的对象。

享元模式是为数不多的、只为提升系统性能而生的设计模式

**主要作用就是复用大对象（重量级对象），以节省内存空间和对象创建时间**。

面向对象可以非常方便的解决一些扩展性的问题，但是在这个过程中系统务必会产生一些类或者对象，如果系统中存在对象的个数过多时，将会导致系统的性能下降。

对于这样的问题解决最简单直接的办法就是减少系统中对象的个数。

享元模式提供了一种解决方案，使用共享技术实现相同或者相似对象的重用。

也就是说实现相同或者相似对象的代码共享。

所谓享元模式就是运行共享技术有效地支持大量细粒度对象的复用。

系统使用少量对象，而且这些都比较相似，状态变化小，可以实现对象的多次复用。

共享模式是支持大量细粒度对象的复用，所以享元模式要求能够共享的对象必须是细粒度对象。

### 首先了解两个概念

- 内部状态
    
    在享元对象内部不随外界环境改变而改变的共享部分。
    
- 外部状态
    
    随着环境的改变而改变，不能够共享的状态就是外部状态。
    

**由于享元模式区分了内部状态和外部状态**，所以我们可以通过设置不同的外部状态使得相同的对象可以具备一些不同的特性，而内部状态设置为相同部分。

在我们的程序设计过程中，我们可能会需要大量的细粒度对象来表示对象，如果这些对象除了几个参数不同外其他部分都相同，这个时候我们就可以利用享元模式来大大减少应用程序当中的对象。

## 如何利用享元模式呢？

这里我们只需要将他们少部分的不同的部分当做参数移动到类实例的外部

然后在方法调用的时候将他们传递过来就可以了。

这里也就说明了一点：内部状态存储于享元对象内部，而外部状态则应该由客户端来考虑

**享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。**

# 享元模式和单例模式的异同

- 享元模式可以再次创建对象 也可以取缓存对象
- 单例模式则是严格控制单个进程中只有一个实例对象
- 享元模式可以通过自己实现对外部的单例 也可以在需要的使用创建更多的对象
- 单例模式是自身控制 需要增加不属于该对象本身的逻辑
- 两者都可以实现节省对象创建的时间 ThreadPool 线程池 与数据库连接池 都有使用享元模式

# 优缺点

## 优点：

1. 可以极大减少内存中对象的数量，使得相同或相似对象在内存中只保存一份，从而可以节约系统资源，提高系统性能。
2. 享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。

## 缺点：

1. 享元模式使得系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。
2. 为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长。

# 使用场景

- 一个系统有大量相同或者相似的对象，造成内存的大量耗费。
- 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。
- 在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式