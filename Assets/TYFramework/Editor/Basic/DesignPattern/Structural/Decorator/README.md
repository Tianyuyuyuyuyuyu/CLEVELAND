# 装饰模式

# 前言

装饰模式实际上是一直提倡的**组合代替继承**的实践方式

要理解装饰者模式首先需要理解为什么需要组合代替继承，继承又是为什么让人深恶痛绝

## 为什么建议使用组合代替继承?

面向对象的特性有继承与封装，但两者却又有一点矛盾，继承意味子类依赖了父类中的实现

一旦父类中改变实现则会对子类造成影响，这是打破了封装性的一种表现.

而组合就是巧用封装性来实现继承功能的代码复用.

# 定义

装饰器模式又名包装(Wrapper)模式。

装饰器模式以对客户端透明的方式拓展对象的功能，是继承关系的一种替代方案。

# 动机

有时我们希望给某个对象而不是整个类添加一些功能。例如，一个图形用户界面工具箱允许你对任意一个用户界面组件添加一些组件，例如边框，或是一些行为，例如窗口滚动等

# 作用

在不修改原有的接口的情况下，让类表现的更好

# 问题

自然是继承有一些问题

继承会导致超类和子类之间存在强耦合性，当超类改变时，子类也会随之改变；

超类的内部细节对于子类是可见的，继承常常被认为破坏了封装性

# 结构

- 抽象构件(Component)角色
    
    给出一个抽象接口，已规范准备接收附加责任的对象。
    
- 具体构件(ConcreteComponent)角色
    
    定义一个将要接收附加责任的类
    
- 装饰(Decorator)角色
    
    持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。
    
- 具体装饰(ConcreteDecorator)角色
    
    负责给构件对象“贴上”附加的责任。
    

# 使用场景

1. 需要扩展一个类的功能或给一个类增加附加责任。
2. 需要动态地给一个对象增加功能，这些功能可以再动态地撤销。
3. 需要增加由一些基本功能的排列组合而产生的非常大量的功能。

# 优缺点

## 优点：

1. 装饰这模式和继承的目的都是扩展对象的功能，但装饰者模式比继承更灵活
2. 通过使用不同的具体装饰类以及这些类的排列组合，设计师可以创造出很多不同行为的组合
3. 装饰者模式有很好地可扩展性

## 缺点：

装饰者模式会导致设计中出现许多小对象，如果过度使用，会让程序变的更复杂。

并且更多的对象会是的差错变得困难，特别是这些对象看上去都很像