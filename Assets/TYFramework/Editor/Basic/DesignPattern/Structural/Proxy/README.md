# 代理模式

# 引言

**数据库**连接是很珍贵的资源，频繁的开关数据库连接是非常浪费服务器的CPU资源以及内存的

所以我们一般都是使用数据库连接池来解决这一问题，

即创造一堆等待被使用的连接，等到用的时候就从池里取一个，不用了再放回去，数据库连接在整个应用启动期间，几乎是不关闭的，除非是超过了最大闲置时间。

但是在程序员编写程序的时候，会经常使用connection.close()这样的方法，去关闭数据库连接，而且这样做是对的，所以你并不能告诉程序员们说，你们使用连接都不要关了，去调用一个其他的类似归还给连接池的方法吧。这是不符合程序员的编程思维的，也很勉强，而且具有风险性，因为程序员会忘的。

解决这一问题的办法就是使用代理模式，因为代理模式可以替代原有类的行为，所以我们要做的就是替换掉connection的close行为。

# 分类

按照**使用目的**可以分为以下几种：

- 远程（Remote）代理
    
    为一个位于不同的地址空间的对象提供一个局域代表对象。这个不同的地址空间可以是本电脑中，也可以在另一台电脑中。最典型的例子就是——客户端调用Web服务或WCF服务。
    
- 虚拟（Virtual）代理
    
    根据需要创建一个资源消耗较大的对象，使得对象只在需要时才会被真正创建。
    
- Copy-on-Write代理
    
    虚拟代理的一种，把复制（或者叫克隆）拖延到只有在客户端需要时，才真正采取行动。
    
- 保护（Protect or Access）代理
    
    控制一个对象的访问，可以给不同的用户提供不同级别的使用权限。
    
- 防火墙（Firewall）代理
    
    保护目标不让恶意用户接近。
    
- 智能引用（Smart Reference）代理
    
    当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来等。
    
- Cache代理
    
    为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以处理这些结果。
    

虚拟代理、远程代理、智能引用代理和保护代理**较为常见**的代理模式。

## 结构

1. Subject（抽象主题角色）
    
    它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。
    
2. Proxy（代理主题角色）
    
    它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。
    
3. RealSubject（真实主题角色）
    
    它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。
    

# 代理模式和装饰模式的异同

代理模式和装饰模式的代码实现方式很相同

### 主要不同点是

代理模式关注与被代理对象行为的控制

然而装饰模式关注于在一个对象上动态的添加方法。

代理模式可以对客户端隐藏被代理对象的具体实现，代理模式的时候常常是在一个代理类中创建一个对象的实例，当使用装饰模式的时候，将原始对象转为一个参数传递给装饰者的构造器中

代理模式强调的是**限制**，装饰模式强调的是**增强**

# 代理模式和委托

代理：是把一些事情交给某人帮忙去完成。

委托：是当某件事情发生的时候，顺便干某件事情。**委托就相当于一个触发器罢了**。

# 应用场景

代理模式的类型较多，不同类型的代理模式有不同的优缺点，它们应用于不同的场合：

1. 当客户端对象需要访问远程主机中的对象时可以使用远程代理。
2. 当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时。
3. 当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。通过使用缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可。
4. 当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理。
5. 当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理。

# 优缺点

## 优点：

1. 能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。
2. 客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性。

## 缺点：

1. 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理。
2. 实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂，例如远程代理。