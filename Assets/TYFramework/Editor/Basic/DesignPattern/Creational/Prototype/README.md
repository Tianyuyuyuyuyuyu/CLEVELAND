# 原型模式

# 前言

单例模式可以避免重复创建消耗资源的对象，但是却不得不共用对象

若是**对象本身也不让随意访问修改时**，怎么办？

通常做法是备份到副本，其它对象操作副本，最后获取权限合并，类似git上的PR操作

# 定义

原型模式用原型实例指定创建对象的种类，并**通过拷贝这些原型创建新的对象**。

需要注意的关键字是，**新的对象，类没变**。

**.NET在System命名空间中提供了Cloneable接口，其中它提供唯一的方法Clone()，只需要实现这个接口就可以完成原型模式了**。

由于它直接操作内存中的二进制流，当大量操作或操作复杂对象时，性能优势将会很明显

# 适用场景

多用于创建大对象，或初始化繁琐的对象。如游戏中的背景，地图。web中的画布等等

以下场景适用：

- 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等；
- **通过 new 产生一个对象需要非常繁琐的数据准备或访问权限**，则可以使用原型模式；
- 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。

在实际项目中，**原型模式很少单独出现，一般是和工厂方法模式一起出现**，通过 clone的方法创建一个对象，然后由工厂方法提供给调用者。

# 实现

被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象，这就是**浅复制**。

但是我们可能需要这样一种需求，要把复制的对象所引用的对象都复制一遍。比如刚才的例子，我希望a、b、c三个引用的对象都是不同的。复制时就一变二，二变三。此时，我们就要用的方式叫“**深复制**”

由于在一些特定场合，会经常涉及深复制和浅复制

比如说，数据集对象DataSet，它就有Clone()方法和Copy()方法

**Clone()方法用来复制DataSet的结构，但不复制DataSet的数据，实现了原型模式的浅复制，**

**Copy()方法不但复制结构，还复制数据，其实就是实现了原型模式的深复制**。

# 总结

原型模式通过Object的clone()方法实现，

**由于是内存操作，无视构造方法和访问权限**，直接获取新的对象。

但**对于引用类型，需使用深拷贝，其它浅拷贝即可**。