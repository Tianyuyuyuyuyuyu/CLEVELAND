# Game Design Pattern

------

## 提炼整理

- 抽象和解耦会让代码的扩展性和灵活性更加强，但会花费额外的实现时间。除非你觉得这样的灵活性有必要，否则没必要过度的去追求。
- 性能优化很重要，但是要注意时机。在整个开发周期中，最好先专注于实现基本需求，把那些可能限制到项目进度的性能优化尽量延后。
- 在整个开发周期中，灵活性和高性能往往不能兼得。我们可以保持代码的灵活性直到设计定下来，再抽出抽象层来提高性能。
- 在原型开发阶段，能尽快让你做出原型产品，最终让产品成功上线的最初的功臣，或许就是设计糟糕的烂代码。因为他们实现想法够快，不需要缜密的设计与架构。只是这些烂代码在经历了原型设计阶段之后，一定要被重写或者重构。
- 如果打算抛弃这段代码，就不要尝试将其写完美。“摇滚明星将旅店房间弄得一团糟，因为他们知道明天会有人来打扫干净。”
- 提倡去写出最简单，最直接的整洁代码。你读过这种代码后，完全理解了它在做什么，想不出其他完成的方法。“完美是可达到的，不是没有东西可以添加的时候，而是没有东西可以删除的时候。”
- 但最重要的是，如果你想要做出让人享受的东西，那就享受完成它的过程。

## 何为好的软件架构

​		书中说到，好的设计意味着当我改了点什么， 整个程序就好像正在等着这种改动。我们可以加入几个函数调用完成任务，同时丝毫不改变代码平静表面下的脉动。

​		这听起来很酷，只是实现起来很难。“把代码写到改变不会影响其平静表面。”若真能做到，确实不错。

​		这样太理想化了，还是让我们通俗些吧。架构是有关于变化的，让我们拥抱变化，从变化开始入手。总有人改动代码。如果没人碰代码，无论是因为代码至善至美，还是糟糕透顶，那么它的架构设计就毫无意义。评价架构设计就是评价它应对变化有多么轻松。没有了变化，它就是永远不会离开起跑线的运动员。

​		轻松应对变化，这就是好的软件架构的主要优点之一。

## 一个新特性的实现过程

​		在改变代码去添加新特性，去修复漏洞，或者随便什么需要使用编辑器的时候，需要理解现在的代码在做些什么。当然，不需要理解整个程序，但需要将所有相关的东西装进大脑。

​		我们通常无视了这步，但这往往是编程中最耗时的部分。 如果你认为将数据从磁盘上分页到RAM上很慢， 那么试着通过一对神经纤维将数据分页到大脑中。

​		一旦你理解了问题和需要改动的代码，实际的编码工作就很容易了

​		你将一些代码加入了游戏，但不想下一个人被你留下来的小问题绊倒。 除非改动很小，否则就还需要一些工作去微调新代码，使之无缝对接到程序的其他部分。如果做对了，那么下个见到代码的人甚至无法说出哪些代码是新加入的。

## 解耦与学习阶段

​		可以用多种方式定义“解耦”，这边是其中之一的理解方式：

​		如果有两块代码是耦合的， 那就意味着无法仅仅只理解了其中一个，而对另一个丝毫不了解。如果解耦了他俩，就可以独自的理解其中之一，根本无需牵扯到另一个。

​		书中说道，我所理解的软件架构的关键目标，就是最小化在处理前需要进入大脑的知识。这也是一种很好的理解方式。

当然，也可以从后期阶段来看。 那么，另一种解耦的定义则是：当一块代码有变化时，没必要修改另外的代码。肯定需要修改一些东西，但耦合程度越小，变化会波及的范围就越小。

## 过度设计的代价

```
有些人喜欢简写为术语“YAGNI”——You aren't gonna need it（你不需要那个）——来对抗预测将来需求的强烈欲望。
```

​		过度去关注设计模式和软件架构，会让一批人很容易地沉浸在代码中，而忽略要自己的最终目的是要发布游戏。无数的开发者听着加强可扩展性的“警世名言”，花费多年时间制作“引擎”，却没有搞清楚做引擎是为了什么。

## 开发周期中因素的动态平衡

在整个开发周期中，如下三大要素一直在相互角力：

- 为了在项目的整个生命周期保持其可读性，我们需要好的架构。
- 需要更好的运行时性能。
- 需要让现在的特性更快的实现。

有趣的是，这三点都是速度：长期开发的速度，游戏运行的速度，和短期开发的速度。

对于这三者的权衡，没有简单明了的解决方案，只有具体问题具体分析，按实际的项目状况去去权衡，让三者保持友好的动态平衡，让整个项目保持良好的状态。
